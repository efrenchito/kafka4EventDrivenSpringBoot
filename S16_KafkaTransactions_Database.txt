ğŸ“¢ Apache Kafka for Event-Driven Spring Boot Microservices  by Sergety Kargopolov
=======================================================================================================================================

ğŸ“ S01 : Apache Kafka Introduction 
ğŸ“ S02 : Apache Kafka Broker
ğŸ“ S03 : Kafka Topics - CLI
ğŸ“ S04 : Kafka Producers - CLI
ğŸ“ S05 : Kafka Consumers - CLI
ğŸ“ S06 : Kafka Producer - Spring Boot Microservice
ğŸ“ S07 : Kafka Producer - Acknowledgment & Retries
ğŸ“ S08 : Kafka Producer - Idempotency
ğŸ“ S09 : Kafka Consumer - Spring Boot Microservice
ğŸ“ S10 : Kafka Consumer - Handling Deserialization Errors
ğŸ“ S11 : Kafka Consumer - Kafka Consumer Dead Letter Topic
ğŸ“ S12 : Kafka Consumer - Exceptions and Retries
ğŸ“ S13 : Kafka Consumer - Multiple Consumers in a Consumer Group
ğŸ“ S14 : Kafka Consumer Idempotency
ğŸ“ S15 : Apache Kafka Transactions
ğŸ“ S16 : Apache Kafka and Database Transactions
ğŸ“ S17 : Integration Testing - Kafka Producer
ğŸ“ S18 : Integration Testing - Kafka Consumer
ğŸ“ S19 : Saga Design Pattern I  - with Apache Kafka
ğŸ“ S20 : Saga Design Pattern II - Compensating Transactions
ğŸ“ S21 : Appendix A: Run Apache Kafka in a Docker Container
ğŸ“ S22 : Appendix B: Install Apache Kafka on Windows





ğŸ“£ Section 16 - Apache Kafka and Database Transactions
=======================================================================================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the following lessons, we'll learn how to use Kafka and Database Transactions together.

In previous lesson, TransferMicroservice.transfer() method was annotated with @Transactional("kafkaTransactionManager")
 -> This means all of our send() methods were executed within a Single Kafka Transaction.
 => To make sure that Consumer Microservices do NOT read messages that were NOT successfully committed
    ...the two Consumer microservices related need to be configured to read committed messages only
    ...spring.kafka.consumer.isolation-level=READ_COMMITTED



ğŸ“ Database + Kafka Operations within a Single  Transaction
---------------

                                    (Producer)
                                     Transfer 
                                   Microservice
   (Client)     Http Request   
   [Postman]   ------------->     RequestHandler                                                    
                                               
                                               
                                @Transactional
                             ----------------------  
                            |       # save()       | -------->  [DB]
                            |                      |                                            (Consumer)
                            |       * send()       | -------->  [withdraw-money-topic]  --->   [Withdrawal]
                            |                      |                                          [Microservice]
                            |        httpCall()    | ----------->  (External Service)
                            |                      |                                            (Consumer) 
                            |       * send()       | -------->  [deposit-money-topic]   --->     [Deposit]
                             ----------------------                                            [Microservice]     
~
ğŸ§ğŸ•µï¸â€â™‚ï¸ğŸ” Notice for this example we'll require two Transaction Managers: 
* KafkaTransactionManager -> Manage Kafka Transactions
# JPATransactionManager   -> Manage Database Transactions



ğŸ“ What happens if you have a single method that require multiple Transactional Managersâ“
---------------
ğŸ¤¯âš ï¸ğŸ§¨ Spring's @Transactional annotation will only use one transaction manager at a time.

Usually the one configured as the primary transaction manager for the @Transactional scope  -> JpaTransactionManager
ğŸ§ğŸ•µï¸â€â™‚ï¸ğŸ”  If you have both JpaTransactionManager and KafkaTransactionManager configured in your Spring context
 -> Spring will use JpaTransactionManager by default to manage the transaction boundary for JPA.
    ..This because JPA is typically considered the main resource for transactional management unless specified otherwise.
 -> In that case Kafka operations will NOT be automatically included in this transaction by Springâ€™s default configuration.
    ..You would need to manually manage Kafka transactions if you want Kafka operations to be part of the same "transactional" flow.
...
This means that while the JPA operations (like database updates) will be committed or rolled back based on the transaction's success/failure
The Kafka operations are not automatically included in the rollback/commit unless explicitly managed.

ğŸ¤¯âš ï¸ğŸ§¨ @Transactional will use JpaTransactionManager by default if NO @Primary Transaction Manager specified
 -> You can change this by using @Primary annotation
 -> Explicitly specifying the target Transaction Manager  
    e.g. @Transactional("kafkaTransactionManager") / @Transactional(transactionManager = "kafkaTransactionManager")





~





ğŸš€ Understanding Spring Transactions
PlatformTransactionManager | TransactionInterceptor | @Transactional Attributes & Nested Transactions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================

ğŸ›¸ What is PlatformTransactionManagerâ“
=====================================================================================================================================
PlatformTransactionManager is a central Spring interface that defines how Spring manages transactions across different underlying resources.
It provides the abstraction layer that allows Spring's @Transactional annotation (and programmatic transaction handling) to work independently
of the specific transaction technology (e.g., JPA, JDBC, Hibernate, Kafka, etc.).

[âœï¸#~/...PlatformTransactionManager.java] >>>
public interface PlatformTransactionManager {
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
}
~
>> Responsibilities of PlatformTransactionManager
 -> Start a transaction (getTransaction)
 -> Commit a transaction (commit)
 -> Rollback a transaction (rollback)
Spring calls these methods behind the scenes when you use @Transactional.

...

ğŸ“ Common Implementations of PlatformTransactionManager
---------------
Implementation	                Used For
DataSourceTransactionManager	  JDBC-based database operations
JpaTransactionManager	          JPA-based persistence (e.g., Hibernate)
HibernateTransactionManager	      Native Hibernate (non-JPA)
JmsTransactionManager	          JMS (Java Messaging Service)
KafkaTransactionManager	          Kafka producer transactions





ğŸ›¸ What is Spring Transaction Interceptorâ“
=====================================================================================================================================
The TransactionInterceptor is a key component of the transaction management system.
It is used to handle the declarative transaction management mechanism in Spring.
The TransactionInterceptor is typically used behind the scenes when applying transaction management to a method, 
and it coordinates with the transaction management API to begin, commit, or rollback transactions.


ğŸ“ Purpose of TransactionInterceptor
---------------
The primary purpose of the TransactionInterceptor is to intercept method calls and manage the transaction boundaries automatically.
It does so by:
 -> Starting a transaction before the method executes.
 -> Committing the transaction if the method execution completes successfully.
 -> Rolling back the transaction if the method execution throws an exception 
    (depending on the exception type and rollback rules).

This is usually done through AOP (Aspect-Oriented Programming)...
where the TransactionInterceptor acts as an aspect that wraps method execution with transaction management logic.


ğŸ“ How Does the TransactionInterceptor Work?
---------------
The TransactionInterceptor works by being part of a proxy (a Spring proxy) that intercepts method invocations 
and applies transaction management logic.
It's most often used when configuring declarative transactions using:
 -> Annotations (@Transactional)
 -> Explicit transaction invocation (Less common approach)
    âœï¸>>> 
	transactionInterceptor.invoke(new TransactionContext(), () -> {
        // Your transactional code
        return null;
	});


ğŸ¤¯âš ï¸ğŸ§¨ Spring Transaction Interceptor manages transactions...
Either for methods annotated with @Transactional or explicit invocations
 o So, when a @Transactional annotated method or transactionInterceptor.invoke() method is called:
   -> First, it will start @Primary / Specific TransactionManager before executing the method
   -> Additionally it will considerate: Nested methods  &  propagation @Transactional attribute





ğŸ›¸ Most important attributes of @Transactional annotation
=====================================================================================================================================
@Transactional in Spring has several attributes...
But in practice a handful of them are the most important because they control:
  -> The Scope | Rollback behavior, and Isolation of your transactions.


ğŸ“ value / transactionManager
 -> @Transactional("jpaTransactionManager")
=> Specifies which transaction manager bean to use

ğŸ“ propagation
 -> REQUIRED (default): Join the existing transaction, or create a new one if none exists.
 -> REQUIRES_NEW: Always create a new, independent transaction. Suspends any existing one.
 -> NESTED: Start a nested transaction using a savepoint (rollback only inner part).
    ... ğŸ‘‰ works only with DataSourceTransactionManager (JDBC).      
 -> SUPPORTS: Join a transaction if one exists, otherwise run non-transactionally.
=> Defines how the method joins or starts a transaction.

ğŸ“ isolation
 -> READ_COMMITTED (default in most DBs)
 -> READ_UNCOMMITTED
 -> REPEATABLE_READ
 -> SERIALIZABLE
 -> DEFAULT (use DB default)
=> Controls visibility of changes between concurrent transactions. Maps to DB isolation levels

ğŸ“ rollbackFor | noRollbackFor
=> Transactional annotation does not roll back transaction for any exception that takes place.
By default, it rolls back transaction for Unchecked exceptions (RuntimeException) and for Errors.
 -> It does NOT roll back transaction on checked exceptions
 -> Usually checked exceptions are the ones that you need to declare and handle in your method
 => But don't worry it's actually configurable via Â´rollbackForÂ´ attribute

ğŸ“ timeout
 -> -1 (no limit)
=> Max time (seconds) before transaction auto-rollback.

ğŸ“ readOnly
 -> false (default value)
=> Marks transaction as read-only (optimizes queries, prevents writes).





ğŸ›¸ Transactional Nested Methods
=====================================================================================================================================
What about having Nested Methodsâ“...This is private methods that perform Transactional operations
You can either, annotate...
 -> Only outer method annotated with @Transactional  ğŸ”Opt1
 -> Both methods annotated with @Transactional       ğŸ”Opt2


ğŸ“ Opt1: Only outer method annotated (@Transactional)
-----
@Transactional("jpaTransactionManager")
public void transfer() {
    send(1);
    saveToDB();
    send(2);
}

public void saveToDB() {
    // Database Operation
}
~
ğŸ§ğŸ•µï¸â€â™‚ï¸ğŸ” >>>>>
 -> There is a single Transaction : No nested or separate transaction is created.
 -> The transaction is controlled solely by the outer method (transfer()).
 -> Rollback/Commit is governed by the outer transaction.
ğŸ¤¯âš ï¸ğŸ§¨ Transaction Manager determines what operations will be rolledback. So, in case of Exception...
  -> @Transactional("jpaTransactionManager")   : Database Operations will be rolled back 
  -> @Transactional("kafkaTransactionManager") : Kafka Messages will remaing uncommitted

...

Springâ€™s @Transactional is implemented via AOP proxying.
If you call another method in the same bean (like this.saveTransferDetails(..)), it bypasses the proxy.
That means any @Transactional annotation on the inner method wouldnâ€™t even be considered (self-invocation problem).
So if saveTransferDetails(..) is not annotated, nothing changes â€” it still participates in the outer transaction.
If it were annotated (e.g., with REQUIRES_NEW), that would only work if the method is called via the proxy (i.e., from another bean, not this.method()).
âœ… In summary:
 -> Without @Transactional on saveToDB(..), it simply executes inside the transaction started by transfer().
 -> The transaction is controlled solely by the outer method (transfer()).
 -> Rollback/commit is governed by the outer transaction.
 -> No nested or separate transaction is created.




ğŸ“ Opt2: Both methods annotated with @Transactional
-----
@Transactional("kafkaTransactionManager")
public void transfer() {
    send(1);
    saveToDB();
    send(2);
}

@Transactional("jpaTransactionManager")
public void saveToDB() {
    // Database Operation
}
~
ğŸ§ğŸ•µï¸â€â™‚ï¸ğŸ” >>>>>
 -> There are two transactions 
 -> Since default propagation is REQUIRED jpaTransaction will be joined to existing transaction
... 
What would happen if saveToDB method uses @Transactional(transactionManager="jpaTransactionManager", propagation="NESTED | REQUIRED_NEW")
So if Kafka Transaction fails, it will rollback Kafka Operations onlyâŒ. However, Database Transaction will commit separately âœ…
âš ï¸ In most cases you would NOT want this to happen
âœ… Probably what you'd want is, if an exception takes place, all operations should be rolledback


ğŸ¤¯âš ï¸ğŸ§¨ @Transactional annotation will have a single transaction by default
   ..unless nested methods are annotated with @Transactional 
   ..or Explicit transaction invocation defined -> transactionInterceptor.invoke | kafkaTemplate.executeInTransaction
 -> What are the default @Transactional attribute values?
    e.g. transactionManager = "jpaTransactionManager" (When available)
    e.g. propagation -> REQUIRED (default)
    e.g. timeout -> -1 (no limit)


âœï¸ >>>  Play around @Transactional transfer() method changing transactionManager and its propagation attributes between nested methods 
ğŸ‘†ğŸ‘†ğŸ‘†ğŸ‘†ğŸ‘†





~





ğŸš€ Demo project & Source Code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================
The project used in this lesson is very similar to the one we used in previous lesson, with a small changes:


                                                                                     [Consumer]           
                                                      ___  Withdrawals Topic   =>  [  Withdraw  ]
                                                     /                             [Microservice]
                                                    /
                                                   /
                                                  /
                        [Transfer Microservice]    
[Transfers Topic]  ->       [Consumer]            \
                            [Producer]             \ 
                                                    \                                 [Consumer]
                                                     \___  Deposits Topic      =>   [  Deposit   ]
                                                                                    [Microservice]

<TransferMicroservice>
[âœï¸#~/...pom.xml]
dependency -> com.h2database:h2


[âœï¸#~/...application.properties]
. . .
spring.h2.console.enabled=true
spring.datasource.driverClassName:org.h2.Driver
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.datasource.url:jdbc:h2:mem:testdb
spring.datasource.username={USERNAME}
spring.datasource.password={PASSWORD}


[âœï¸#~/...TransferEntity.java]
@Entity
@Getter @Setter
@Table(name="transfers")
public class TransferEntity implements Serializable {

    private static final long serialVersionUID = -6202121587624962351L;

	@Id
    @Column(nullable = false)
    private String transferId;

    @Column(nullable = false)
    private String senderId;

    @Column(nullable = false)
    private String recepientId;

    @Column(nullable = false)
    private BigDecimal amount;

    public TransferEntity() {
    }
 
    public TransferEntity(String transferId, String senderId, String recepientId, BigDecimal amount) {
        this.transferId = transferId;
        this.senderId = senderId;
        this.recepientId = recepientId;
        this.amount = amount;
    }

}


[âœï¸#~/...TransferRepository.java]
public interface TransferRepository extends JpaRepository<TransferEntity, String> {

}





~





ğŸš€ Creating JPA Transaction Manager
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================

<TransferService>
[âœï¸#~/...TransfersController.java]
@RestController
@RequestMapping("/transfers")
public class TransfersController {
    private final Logger LOGGER = LoggerFactory.getLogger(this.getClass());
    private TransferService transferService;

    public TransfersController(TransferService transferService) {
        this.transferService = transferService;
    }

    @PostMapping()
    public boolean transfer(@RequestBody TransferRestModel transferRestModel) {
ğŸ’¥      return transferService.transfer(transferRestModel);
    }
}

...

ğŸ§ğŸ•µï¸â€â™‚ï¸ğŸ” When working with @Transactional
Spring by default will look for a Transaction Manager called "transactionManager"
When your application already contains Transaction Manager it won't create a default TransactionManager @Bean

You can just pass the name of target bean as attribute to @Transactional annotation
e.g. 
@Transactional("kafkaTransactionManager")
@Transactional(transactionManager = "kafkaTransactionManager")


@Bean("kafkaTransactionManager")
KafkaTransactionManager<String, Object> KafkaTransactionManager(ProducerFactory<String, Object> producerFactory) {
    return new KafkaTransactionManager<>(producerFactory);
}

@Bean("transactionManager")
JpaTransactionManager jpaTransactionManager(EntityManagerFactory entityManagerFactory) {
    return new JpaTransactionManager(entityManagerFactory);
}





~






ğŸš€ Synchronized Transaction: Saving to Database
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================
In this lesson, we'll save information to a Database table using the TransferServiceImpl.transfer() method annotated with @Transactional


[âœï¸#~/...TransferServiceImpl.java]
@Service
public class TransferServiceImpl implements TransferService {
	private final Logger LOGGER = LoggerFactory.getLogger(this.getClass());

	private KafkaTemplate<String, Object> kafkaTemplate;
	private Environment environment;
	private RestTemplate restTemplate;
ğŸ’¥  private TransferRepository transferRepository;

	public TransferServiceImpl(KafkaTemplate<String, Object> kafkaTemplate, Environment environment,
			RestTemplate restTemplate, ğŸ’¥TransferRepository transferRepositoryğŸ’¥) {
		this.kafkaTemplate = kafkaTemplate;
		this.environment = environment;
		this.restTemplate = restTemplate;
ğŸ’¥      this.transferRepository = transferRepository;
	}


âŒ Only outer method annotated [@Transactional("jpaTransactionManager")]
 -> Will Rollback only Database Operations in case of Exception thrown
===================================
	@Transactional("transactionManager")
	@Override
	public boolean transfer(TransferRestModel transferRestModel) {
		WithdrawalRequestedEvent withdrawalEvent = new WithdrawalRequestedEvent(transferRestModel.getSenderId(),
				transferRestModel.getRecepientId(), transferRestModel.getAmount());
		DepositRequestedEvent depositEvent = new DepositRequestedEvent(transferRestModel.getSenderId(),
				transferRestModel.getRecepientId(), transferRestModel.getAmount());
	
		try {
			
ğŸ’¥          //Save record to a database table
ğŸ’¥          saveTransferDetails(transferRestModel);
			
			kafkaTemplate.send(environment.getProperty("withdraw-money-topic", "withdraw-money-topic"),
					withdrawalEvent);
			LOGGER.info("Sent event to withdrawal topic.");

			// Business logic that causes and error
			callRemoteServce();

			kafkaTemplate.send(environment.getProperty("deposit-money-topic", "deposit-money-topic"), depositEvent);
			LOGGER.info("Sent event to deposit topic");

		} catch (Exception ex) {
			LOGGER.error(ex.getMessage(), ex);
			throw new TransferServiceException(ex);
		}

		return true;
	}


âœ… Using @Transactional("jpaTransactionManager") + kafkaTemplate.executeInTransaction(...)
 -> Will Rollback both Database and Kafka Operations in case of Exception thrown
===================================
ğŸ’¥  @Transactional("jpaTransactionManager")
	public boolean transfer(TransferRestModel transferRestModel) {
		WithdrawalRequestedEvent withdrawalEvent = new WithdrawalRequestedEvent(
				transferRestModel.getSenderId(),
				transferRestModel.getRecepientId(),
				transferRestModel.getAmount());
		DepositRequestedEvent depositEvent = new DepositRequestedEvent(
				transferRestModel.getSenderId(),
				transferRestModel.getRecepientId(),
				transferRestModel.getAmount());

		kafkaTemplate.executeInTransaction(kafkaProducer -> {
			
			saveTransferDetails(transferRestModel);

			kafkaTemplate.send(environment.getProperty("withdraw-money-topic", "withdraw-money-topic"),
					withdrawalEvent);
			LOGGER.info("Sent event to withdrawal topic.");

			callRemoteService();

			kafkaTemplate.send(environment.getProperty("deposit-money-topic", "deposit-money-topic"), depositEvent);
			LOGGER.info("Sent event to deposit topic.");

			return true;
		});

		return true;
	}

ğŸ’¥  private void saveTransferDetails(TransferRestModel transferRestModel) {
ğŸ’¥  	TransferEntity transferEntity = new TransferEntity();
ğŸ’¥  	BeanUtils.copyProperties(transferRestModel, transferEntity);
ğŸ’¥  	transferEntity.setTransferId(Uuid.randomUuid().toString());
ğŸ’¥  	
ğŸ’¥  	// Save record to a database table
ğŸ’¥  	transferRepository.save(transferEntity);
ğŸ’¥  }


	private ResponseEntity<String> callRemoteServce() throws Exception {
		String requestUrl = "http://localhost:8082/response/200";
		ResponseEntity<String> response = restTemplate.exchange(requestUrl, HttpMethod.GET, null, String.class);

		if (response.getStatusCode().value() == HttpStatus.SERVICE_UNAVAILABLE.value()) {
			throw new Exception("Destination Microservice not availble");
		}

		if (response.getStatusCode().value() == HttpStatus.OK.value()) {
			LOGGER.info("Received response from mock service: " + response.getBody());
		}
		return response;
	}

}
~
ğŸ§ğŸ•µï¸â€â™‚ï¸ğŸ” TransferEntity fields are exactly the same as those defined in TransferRestModel class.
So, I can copy the values from one object to another by using Spring BeanUtils helper class (.copyProperties())
...
ğŸ¤¯âš ï¸ğŸ§¨ Defining a try-catch and then logging and throwing your own custom exception in the catch block
 -> Allows you to have control on what is being logged in case of exception and the specific Exception that should be thrown
âœï¸>>>
	kafkaTemplate.executeInTransaction(kafkaProducer -> {
		try {
			//DB + Kafka Operations
		} catch (Exception ex) {
			LOGGER.error(ex.getMessage(), ex);
			throw new TransferServiceException(ex);
		}
		return true;
	});	





~






ğŸš€ Enable logging for Kafka and Jpa Transaction Managers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================

[âœï¸#~/...application.properties]
logging.level.org.springframework.transaction=DEBUG
logging.level.org.springframework.orm.jpa.JpaTransactionManager=DEBUG
logging.level.org.springframework.kafka.transaction.KafkaTransactionManager=DEBUG
logging.level.org.apache.kafka.clients.producer.internals.TransactionManager=DEBUG





~






ğŸš€ Trying how Synchronized Transactions work
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================

ğŸ“ Make sure microservices are up and running >>>

[IntelliJ]
TransferMicroservice
  > â–¶ï¸ TransferServiceApplication

[IntelliJ]
MockResponseMicroservice
  > â–¶ï¸ MockResponseServiceApplication

[IntelliJ]
WithdrawalMicroservice
  > â–¶ï¸ WithdrawalServiceApplication

[IntelliJ]
DepositMicroservice
  > â–¶ï¸ DepositServiceApplication

...

âœï¸>>> Let's make a Transfer Request  ğŸ‘‡...
[POSTMAN]
[POST] http://localhost:{PORT}/transfers
{
    "senderId": "123",
    "recepientId": "234",
    "amount": 250
}
~
âœ… Status: 200 Ok    Time: 46 ms    Size: 264 B


ğŸ” Check Database and Kakfa Consumer Services logs