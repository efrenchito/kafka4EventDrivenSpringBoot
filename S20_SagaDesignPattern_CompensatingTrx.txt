üì¢ Apache Kafka for Event-Driven Spring Boot Microservices  by Sergety Kargopolov
=======================================================================================================================================

üìù S01 : Apache Kafka Introduction 
üìù S02 : Apache Kafka Broker
üìù S03 : Kafka Topics - CLI
üìù S04 : Kafka Producers - CLI
üìù S05 : Kafka Consumers - CLI
üìù S06 : Kafka Producer - Spring Boot Microservice
üìù S07 : Kafka Producer - Acknowledgment & Retries
üìù S08 : Kafka Producer - Idempotency
üìù S09 : Kafka Consumer - Spring Boot Microservice
üìù S10 : Kafka Consumer - Handling Deserialization Errors
üìù S11 : Kafka Consumer - Kafka Consumer Dead Letter Topic
üìù S12 : Kafka Consumer - Exceptions and Retries
üìù S13 : Kafka Consumer - Multiple Consumers in a Consumer Group
üìù S14 : Kafka Consumer Idempotency
üìù S15 : Apache Kafka Transactions
üìù S16 : Apache Kafka and Database Transactions
üìù S17 : Integration Testing - Kafka Producer
üìù S18 : Integration Testing - Kafka Consumer
üìù S19 : Saga Design Pattern I  - with Apache Kafka
üìù S20 : Saga Design Pattern II - Compensating Transactions
üìù S21 : Appendix A: Run Apache Kafka in a Docker Container
üìù S22 : Appendix B: Install Apache Kafka on Windows





üì£ Section 20 - Saga Design Pattern II - Compensating Transactions
=======================================================================================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


üöÄ Introduction to Compensating Transactions in Saga
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================
In the following lessons, we will implement Compensating Transactions for our Order Flow.
As we've already mentioned:
 -> << Saga is an Event-handling Component that manages sequence of local transactions >>


In previous lessons.. 
We've created a Simple Order Flow managed by Saga.
It handled multiple events and then it published a command to trigger the next local transaction in Saga.
Now if one of these local transaction fails, then saga will need to perform a series of compensating transactions.
Notice these transactions should undo changes that were made by preceding transactions.


                 [Order Saga]
            Handle OrderCreatedEvent          
                                            
              ReserveProductCommand  --------   Products
                                               Microservice
              ProductReservedEvent   --------
 
              ProcessPaymentCommand‚ùå--------   Payment
                                               Microservice
              PaymentProcessedEvent   --------


üßêüïµÔ∏è‚Äç‚ôÇÔ∏èüîé If ProcessPaymentCommand fails..
 -> Then saga will need to undo preceding modifying transaction which is reserved product command.
 -> If there were more modifying transactions performed, then saga will need to undo each of them, but in reverse order.

...

ü§Ø‚ö†Ô∏èüß® In Saga design, pattern compensating transactions are performed in a reverse order.
ü§Ø‚ö†Ô∏èüß® Another very important point to mention is that 
  -> You do not need to perform compensating transactions for those steps in saga that did not do any changes in your system.
ü§Ø‚ö†Ô∏èüß® It's a good practice to store history of events.


üìù Preserve History of Events
---------------
Each microservice works with its own database and for the orders microservice I created additional database table that I called history.
This database table keeps track of order statuses and when order status was changed after I perform compensation transaction, 
I will update order status in orders database. But I will not change any existing records in the history database table.
And this is because history events do not change. 
 -> Instead of updating existing records in the history table, I will add a new record to it.

üïµÔ∏è‚Äç‚ôÇÔ∏è Orders Database

o Orders
[ ID     |   TITLE   |  PRICE  | STATUS  ]
[d6f2d6c5| iPhone 11 |  800    | rejected]


o Orders History
[ORDERID  |  PRODUCTID |  STATUS  |    TIMESTAMP  ]
[d6f2d6c5 |   4EE43C56 |  created | 1721065476355 ]
[d6f2d6c5 |   4EE43C56 | rejected | 1721065871157 ]

üßêüïµÔ∏è‚Äç‚ôÇÔ∏èüîé Keeping order history is very helpful for auditing and debugging, 
and it is very similar to Event Sourcing Design Pattern that is often used in Microservices Architecture.
When event sourcing is used, we keep history of all events that take place.
History records help us rebuild or reconstruct state of any entity at any point in time, which is very
helpful for auditing, debugging and compliance purposes.

ü§Ø‚ö†Ô∏èüß® When executing compensating transactions...
 -> We should NOT Add / Delete records from history database table.





~





üöÄ Handle PaymentFailedEvent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================
In previous lessons, we implemented Order Saga, but we worked on a happy path only.
In this lesson, we'll start working on a use case where an exception takes place and we need to perform Compensating Transaction.

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù payment-service
[‚úèÔ∏è#~/...com.appsdeveloperblog.payments.handler.PaymentsCommandsHandler]
@Component
@KafkaListener(topics="${payments.commands.topic.name}")
public class PaymentsCommandHandler {

  private final Logger logger = LoggerFactory.getLogger(this.getClass());
  private final PaymentService paymentService;
  private final KafkaTemplate<String, Object> kafkaTemplate;
  private final String paymentEventsTopicName;

  public PaymentsCommandsHandler(
    PaymentService paymentService,
    KafkaTemplate<String, Object> kafkaTemplate,
    @Value("${payments.events.topic.name}") String paymentEventsTopicName
  ) {
    this.paymentService = paymentService;
    this.kafkaTemplate = kafkaTemplate;
    this.paymentEventsTopicName = paymentEventsTopicName;
  }

  @KafkaHandler
  public void handleCommand(@Payload ProcessPaymentCommand command) {

    try{
      Payment payment = new Payment(
      command.getOrderId(), command.getProductId(), command.getProductPrice(), command.getProductQuantity());
      Payment processedPayment = paymentService.process(payment);
üí•    PaymentProcessedEvent paymentProcessedEvent = new PaymentProcessedEvent(
üí•      processedPayment.getOrderId(), processedPayment.getId());
üí•   
üí•    kafkaTemplate.send(payemntEventsTopicName, paymentProcessedEvent);
    } catch(CreditCardProcessorUnavailableException e) {
      logger.error(e.getLocalizedMessage(), e);
üí•    PaymentFailedEvent paymentFailedEvent = new PaymentFailedEvent(
üí•        command.getOrderId(), command.getProductId(), command.getProductQuantity());
üí•    kafkaTemplate.send(paymentEventsTopicName, paymentFailedEvent);
    }

  }
  
}
~
üßêüïµÔ∏è‚Äç‚ôÇÔ∏èüîé This class defines @KafkaHandler annotated method ¬¥handleCommand¬¥ which takes a ProcessPaymentCommand
If payment is processed successfully it publishes PaymentProcessedEvent.
However if payment fails and exception is thrown and we publish PaymentFailedEvent
 -> This is our signal to begin Compensating Transaction
    ..So, we need to remove ProductReservation for a product



[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù order-service
[‚úèÔ∏è#~/...com.appsdeveloperblog.orders.saga.OrderSaga]
package com.appsdeveloperblog.orders.saga;

@Component
@KafkaListener(topics={
üîé"${orders.events.topic.name}",
  "${products.events.topic.name}"
  "${payments.events.topic.name}"
})
public class OrderSaga {

  private final KafkaTemplate<String, Object> kafkaTemplate;
  private final String productsCommandTopicName;
  private final OrderHistoryService orderHistoryService;
  private final String paymentsCommandsTopicName;
  private final String orderCommandsTopicName;

  public OrderSaga(
    KafkaTemplate<String, Object> kafkaTemplate,
    @Value("${products.commands.topic.name}") String productsCommandTopicName,
    OrderHistoryService orderHistoryService,
    @Value("${payments.commands.topic.name}") String paymentsCommandsTopicName
    @Value("${orders.commands.topic.name}") String ordersCommandsTopicName
  ) {
    this.kafkaTemplate = kafkaTemplate;
    this.productsCommandsTopicName = productsCommandsTopicName;
    this.orderHistory = orderHistory;
    this.paymentsCommandsTopicName = paymentsCommandsTopicName
  }

  @KafkaHandler
  public void handleEvent(@Payload OrderCreatedEvent event) {

    ReserveProductCommand command = new ReserveProductCommand(
      event.getProductId(),
      event.getProductQuantity(),
      event.getOrderId()
    );

    kafkaTemplate.send(productsCommandsTopicName, command);
    orderHistoryService.add(event.getOrderId(), OrderStatus.CREATED);

  }

  @KafkaHandler
  public void handleEvent(@Payload ProductReservedEvent event) {
  
    ProcessPaymentCommand ProcessPaymentCommand = new ProcessPaymentCommand(
      event.getOrderId(), event.getProductId(), event.getProductPrice(), event.getProductQuantity());
    kafkaTemplate.send(paymentsCommandsTopicName, ProcessPaymentCommand);
  }

  @KafkaHandler
  public void handleEvent(@Payload PaymentProcessedEvent event) {
  
    ApprovedOrderCommand approvedOrderCommand = new ApprovedOrderCommand(event.getOrderId());
    kafkaTemplate.send(ordersCommandsTopicName, approvedOrderCommand);
    
  }

  @KafkaHandler
  public void handleEvent(@Payload OrderApprovedEvent event) {
    orderHistoryService.add(event.getOrderId(), OrderStatus.APPROVED);
  }

üí•@KafkaHandler
üí•public void handleEvent(@Payload PaymentFailedEvent event) {
üí•  //TODO: Publish CancelProductReservationCommand
üí•}

}





~





üöÄ Publish CancelProductReservationCommand
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù core
  src>main>java
    com.appsdeveloperblog.core.dto.commands
    ‚ûï CancelProductReservationCommand.java

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù core
[‚úèÔ∏è#~/...com.appsdeveloperblog.core.dto.commands.CancelProductReservationCommand]
@Getters
@Setters
@NoArgsConstructor
@AllArgsConstructor
public class CancelProductReservationCommand {
    private UUID productId;
    private UUID orderId;
    private Integer productQuantity;
}

[terminal]
$ mvn install


~

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù order-service
[‚úèÔ∏è#~/...com.appsdeveloperblog.orders.saga.OrderSaga]
package com.appsdeveloperblog.orders.saga;

@Component
@KafkaListener(topics={
üîé"${orders.events.topic.name}",
  "${products.events.topic.name}"
  "${payments.events.topic.name}"
})
public class OrderSaga {

  private final KafkaTemplate<String, Object> kafkaTemplate;
  private final String productsCommandTopicName;
  private final OrderHistoryService orderHistoryService;
  private final String paymentsCommandsTopicName;
  private final String orderCommandsTopicName;

  public OrderSaga(
    KafkaTemplate<String, Object> kafkaTemplate,
    @Value("${products.commands.topic.name}") String productsCommandTopicName,
    OrderHistoryService orderHistoryService,
    @Value("${payments.commands.topic.name}") String paymentsCommandsTopicName
    @Value("${orders.commands.topic.name}") String ordersCommandsTopicName
  ) {
    this.kafkaTemplate = kafkaTemplate;
    this.productsCommandsTopicName = productsCommandsTopicName;
    this.orderHistory = orderHistory;
    this.paymentsCommandsTopicName = paymentsCommandsTopicName
  }

  @KafkaHandler
  public void handleEvent(@Payload OrderCreatedEvent event) {

    ReserveProductCommand command = new ReserveProductCommand(
      event.getProductId(),
      event.getProductQuantity(),
      event.getOrderId()
    );

    kafkaTemplate.send(productsCommandsTopicName, command);
    orderHistoryService.add(event.getOrderId(), OrderStatus.CREATED);

  }

  @KafkaHandler
  public void handleEvent(@Payload ProductReservedEvent event) {
  
    ProcessPaymentCommand ProcessPaymentCommand = new ProcessPaymentCommand(
      event.getOrderId(), event.getProductId(), event.getProductPrice(), event.getProductQuantity());
    kafkaTemplate.send(paymentsCommandsTopicName, ProcessPaymentCommand);
  }

  @KafkaHandler
  public void handleEvent(@Payload PaymentProcessedEvent event) {
  
    ApprovedOrderCommand approvedOrderCommand = new ApprovedOrderCommand(event.getOrderId());
    kafkaTemplate.send(ordersCommandsTopicName, approvedOrderCommand);
    
  }

  @KafkaHandler
  public void handleEvent(@Payload OrderApprovedEvent event) {
    orderHistoryService.add(event.getOrderId(), OrderStatus.APPROVED);
  }

üí•@KafkaHandler
üí•public void handleEvent(@Payload PaymentFailedEvent event) {
üí•  CancelProductReservationCommand cancelProductReservcationCommand =
üí•    new CancelProductReservationCommand(event.getProductId(), event.getOrderId(), event.getProductQuantity());
üí•  kafkaTemplate.send(productsCommandsTopicName, cancelProductReservcationCommand);
üí•}

}





~





üöÄ Handle CancelProductReservationCommand
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================

[‚úèÔ∏è#~/...ProductService.java]
package com.appsdeveloperblog.products.service;

import com.appsdeveloperblog.core.dto.Product;

import java.util.List;
import java.util.UUID;

public interface ProductService {
    List<Product> findAll();
    Product reserve(Product desiredProduct, UUID orderId);
üí•  void cancelReservation(Product productToCancel, UUID orderId);
    Product save(Product product);
}


[‚úèÔ∏è#~/...ProductServiceImpl.java]
package com.appsdeveloperblog.products.service;

import com.appsdeveloperblog.core.dto.Product;
import com.appsdeveloperblog.core.exceptions.ProductInsufficientQuantityException;
import com.appsdeveloperblog.products.dao.jpa.entity.ProductEntity;
import com.appsdeveloperblog.products.dao.jpa.repository.ProductRepository;
import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class ProductServiceImpl implements ProductService {
    private final ProductRepository productRepository;

    public ProductServiceImpl(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @Override
    public Product reserve(Product desiredProduct, UUID orderId) {
        ProductEntity productEntity = productRepository.findById(desiredProduct.getId()).orElseThrow();
        if (desiredProduct.getQuantity() > productEntity.getQuantity()) {
            throw new ProductInsufficientQuantityException(productEntity.getId(), orderId);
        }

        productEntity.setQuantity(productEntity.getQuantity() - desiredProduct.getQuantity());
        productRepository.save(productEntity);

        var reservedProduct = new Product();
        BeanUtils.copyProperties(productEntity, reservedProduct);
        reservedProduct.setQuantity(desiredProduct.getQuantity());
        return reservedProduct;
    }

üí•  @Override
üí•  public void cancelReservation(Product productToCancel, UUID orderId) {
üí•      ProductEntity productEntity = productRepository.findById(productToCancel.getId()).orElseThrow();
üí•      productEntity.setQuantity(productEntity.getQuantity() + productToCancel.getQuantity());
üí•      productRepository.save(productEntity);
üí•  }

    @Override
    public Product save(Product product) {
        ProductEntity productEntity = new ProductEntity();
        productEntity.setName(product.getName());
        productEntity.setPrice(product.getPrice());
        productEntity.setQuantity(product.getQuantity());
        productRepository.save(productEntity);

        return new Product(productEntity.getId(), product.getName(), product.getPrice(), product.getQuantity());
    }

    @Override
    public List<Product> findAll() {
        return productRepository.findAll().stream()
                .map(entity -> new Product(entity.getId(), entity.getName(), entity.getPrice(), entity.getQuantity()))
                .collect(Collectors.toList());
    }
}

...

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù product-service
[‚úèÔ∏è#~/...com.appsdeveloperblog.products.service.handler.ProductCommandsHandler]
@Component
@KafkaListener(topics={"${products.commands.topic.name}"})
public class ProductCommandsHandler {

  private final ProductService productService;
  private final Logger logger = LoggerFactory.getLogger(this.getClass());
  private final KafkaTemplate<String, Object> kafkaTemplate;
  private final String productEventsTopicName;

  public ProductCommandsHandler(
    ProductService productService,
    KafkaTemplate<String, Object> kafkaTemplate
    @Value("${products.events.topic.name}") String productEventsTopicName
  ) {
    this.productService = productService;
  }

  @KafkaHandler
  public void handleCommand(@Payload ReserveProductCommand command) {

    try {
      Product desiredProduct = new Product(command.getProductId(), command.getProductQuantity());
      Product reservedProduct = productService.reserve(desiredProduct, command.getOrderId());
      ProductReservedEvent productReservedEvent = new ProductReservedEvent(
        command.getOrderId(),
        command.getProductId(),
        reservedProduct.getPrice(),
        command.getProductQuantity());
        kafkaTemplate.send(productEventsTopicName, productReservedEvent);
    } catch(Exception e) {
      logger.error(e.getLocalizedMessage(), e);
      ProductReservationFailedEvent productReservationFailedEvent = new ProductReservationFailedEvent(
        command.getProductId(),
        command.getOrderId(),
        command.getProductQuantity() 
      );    
    }  

  }

üí•@KafkaHandler
üí•public void handleCommand(@Payload CancelProductReservationCommand command) {
üí•  Product productToCancel = new Product(command.getProductId(), command.getProductQuantity());
üí•  productService.cancelReservation(productToCancel, command.getOrderId());
üí•}
}
~
üßêüïµÔ∏è‚Äç‚ôÇÔ∏èüîé Now that we've canceled product reservation...
 -> We need to notify saga about it
 => So, we'll publish ¬¥ProductReservationCancelledEvent¬¥





~





üöÄ Publish ProductReservationCancelledEvent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================
In this lesson, we are going to notify saga that product reservation has been canceled
and to do it we'll publish new event that is called ¬¥ProductReservationCancelledEvent¬¥

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù core
  src>main>java
    com.appsdeveloperblog.core.dto.commands
    ‚ûï ProductReservationCancelledEvent.java

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù core
[‚úèÔ∏è#~/...com.appsdeveloperblog.core.dto.commands.ProductReservationCanceledEvent]
@Getters
@Setters
@NoArgsConstructor
@AllArgsConstructor
public class ProductReservationCanceledEvent {
    private UUID productId;
    private UUID orderId;
}

[terminal]
$ mvn install

~

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù product-service
[‚úèÔ∏è#~/...com.appsdeveloperblog.products.service.handler.ProductCommandsHandler]
@Component
@KafkaListener(topics={"${products.commands.topic.name}"})
public class ProductCommandsHandler {

  private final ProductService productService;
  private final Logger logger = LoggerFactory.getLogger(this.getClass());
  private final KafkaTemplate<String, Object> kafkaTemplate;
  private final String productEventsTopicName;

  public ProductCommandsHandler(
    ProductService productService,
    KafkaTemplate<String, Object> kafkaTemplate
    @Value("${products.events.topic.name}") String productEventsTopicName
  ) {
    this.productService = productService;
  }

  @KafkaHandler
  public void handleCommand(@Payload ReserveProductCommand command) {

    try {
      Product desiredProduct = new Product(command.getProductId(), command.getProductQuantity());
      Product reservedProduct = productService.reserve(desiredProduct, command.getOrderId());
      ProductReservedEvent productReservedEvent = new ProductReservedEvent(
        command.getOrderId(),
        command.getProductId(),
        reservedProduct.getPrice(),
        command.getProductQuantity());
        kafkaTemplate.send(productEventsTopicName, productReservedEvent);
    } catch(Exception e) {
      logger.error(e.getLocalizedMessage(), e);
      ProductReservationFailedEvent productReservationFailedEvent = new ProductReservationFailedEvent(
        command.getProductId(),
        command.getOrderId(),
        command.getProductQuantity() 
      );    
    }  

  }

üí•@KafkaHandler
üí•public void handleCommand(@Payload CancelProductReservationCommand command) {
üí•  Product productToCancel = new Product(command.getProductId(), command.getProductQuantity());
üí•  productService.cancelReservation(productToCancel, command.getOrderId());
üí•
üí•  ProductReservationCancelledEvent productReservationCancelledEvent = 
üí•    new ProductReservationCancelledEvent(command.getProductId(), command.getOrderId());
üí•  kafkaTemplate.send(productEventsTopicName, productReservationCancelledEvent);
üí•}
}





~





üöÄ Handle ProductReservationCancelledEvent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù core
  src>main>java
    com.appsdeveloperblog.core.dto.commands
    ‚ûï RejectOrderCommand.java

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù core
[‚úèÔ∏è#~/...com.appsdeveloperblog.core.dto.commands.RejectOrderCommand]
@Getters
@Setters
@NoArgsConstructor
@AllArgsConstructor
public class RejectOrderCommand {
    private UUID orderId;
}

[terminal]
$ mvn install

~

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù order-service
[‚úèÔ∏è#~/...com.appsdeveloperblog.orders.saga.OrderSaga]
package com.appsdeveloperblog.orders.saga;

@Component
@KafkaListener(topics={
üîé"${orders.events.topic.name}",
  "${products.events.topic.name}"
  "${payments.events.topic.name}"
})
public class OrderSaga {

  private final KafkaTemplate<String, Object> kafkaTemplate;
  private final String productsCommandTopicName;
  private final OrderHistoryService orderHistoryService;
  private final String paymentsCommandsTopicName;
  private final String orderCommandsTopicName;

  public OrderSaga(
    KafkaTemplate<String, Object> kafkaTemplate,
    @Value("${products.commands.topic.name}") String productsCommandTopicName,
    OrderHistoryService orderHistoryService,
    @Value("${payments.commands.topic.name}") String paymentsCommandsTopicName
    @Value("${orders.commands.topic.name}") String ordersCommandsTopicName
  ) {
    this.kafkaTemplate = kafkaTemplate;
    this.productsCommandsTopicName = productsCommandsTopicName;
    this.orderHistory = orderHistory;
    this.paymentsCommandsTopicName = paymentsCommandsTopicName
  }

  @KafkaHandler
  public void handleEvent(@Payload OrderCreatedEvent event) {

    ReserveProductCommand command = new ReserveProductCommand(
      event.getProductId(),
      event.getProductQuantity(),
      event.getOrderId()
    );

    kafkaTemplate.send(productsCommandsTopicName, command);
    orderHistoryService.add(event.getOrderId(), OrderStatus.CREATED);

  }

  @KafkaHandler
  public void handleEvent(@Payload ProductReservedEvent event) {
  
    ProcessPaymentCommand ProcessPaymentCommand = new ProcessPaymentCommand(
      event.getOrderId(), event.getProductId(), event.getProductPrice(), event.getProductQuantity());
    kafkaTemplate.send(paymentsCommandsTopicName, ProcessPaymentCommand);
  }

  @KafkaHandler
  public void handleEvent(@Payload PaymentProcessedEvent event) {
  
    ApprovedOrderCommand approvedOrderCommand = new ApprovedOrderCommand(event.getOrderId());
    kafkaTemplate.send(ordersCommandsTopicName, approvedOrderCommand);
    
  }

  @KafkaHandler
  public void handleEvent(@Payload OrderApprovedEvent event) {
    orderHistoryService.add(event.getOrderId(), OrderStatus.APPROVED);
  }

  @KafkaHandler
  public void handleEvent(@Payload PaymentFailedEvent event) {
    CancelProductReservationCommand cancelProductReservcationCommand =
      new CancelProductReservationCommand(event.getProductId(), event.getOrderId(), event.getProductQuantity());
    kafkaTemplate.send(productsCommandsTopicName, cancelProductReservcationCommand);
  }

üí•@KafkaHandler
üí•public void handleEvent(@Payload ProductReservationCancelledEvent event) {
üí•  RejectOrderCommand rejectOrderCommand = new RejectOrderCommand(even.getOrderId());
üí•  kafkaTemplate.send(ordersCommandTopicName, rejectOrderCommand);
üí•  orderHistoryService.add(event.getOrderId(), OrderStatusRejected);
üí•}  
}





~





üöÄ Handle RejectOrderCommand
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================

[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù order-service

[‚úèÔ∏è#~/...OrderService]
public interface OrderService {
  Order placeOrder(Order order);
  void approveOrder(UUID orderId);
üí•  void rejectOrder(UUID orderId);
}


[‚úèÔ∏è#~/...OrderServiceImpl]
@Service
public class OrderServiceImpl implements OrderService {
    private final OrderRepository orderRepository;

    public OrderServiceImpl(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    @Override
    public Order placeOrder(Order order) {
        OrderEntity entity = new OrderEntity();
        entity.setCustomerId(order.getCustomerId());
        entity.setProductId(order.getProductId());
        entity.setProductQuantity(order.getProductQuantity());
        entity.setStatus(OrderStatus.CREATED);
        orderRepository.save(entity);

        return new Order(
                entity.getId(),
                entity.getCustomerId(),
                entity.getProductId(),
                entity.getProductQuantity(),
                entity.getStatus());
    }

    @Override
    public void approveOrder(UUID orderId) {
        OrderEntity orderEntity = orderRepository
            .findById(orderId)
            .orElseThrow("No order is found with id " + orderId + "in the database table");
        orderEntity.setStatus(OrderStatus.APPROVED);
        orderRepository.save(orderEntity);
        OrderApprovedEvent orderApprovedEvent = new OrderApprovedEvent(orderId);
        kafkaTemplate.send(ordersEventTopicName, orderApprovedEvent);
    }

[‚úèÔ∏è#~/...OrderService]
public interface OrderService {
  Order placeOrder(Order order);
  void approveOrder(UUID orderId);
}


[‚úèÔ∏è#~/...OrderServiceImpl]
@Service
public class OrderServiceImpl implements OrderService {
    private final OrderRepository orderRepository;

    public OrderServiceImpl(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    @Override
    public Order placeOrder(Order order) {
        OrderEntity entity = new OrderEntity();
        entity.setCustomerId(order.getCustomerId());
        entity.setProductId(order.getProductId());
        entity.setProductQuantity(order.getProductQuantity());
        entity.setStatus(OrderStatus.CREATED);
        orderRepository.save(entity);

        return new Order(
                entity.getId(),
                entity.getCustomerId(),
                entity.getProductId(),
                entity.getProductQuantity(),
                entity.getStatus());
    }

üí•  @Override
üí•  public void rejectOrder(UUID orderId) {
üí•      OrderEntity orderEntity = orderRepository.findById(orderId).orElse(null);
üí•      Assert.notNull(orderEntity, "No order found with id: " + orderId);
üí•      orderEntity.setStatus(OrderStatus.REJECTED);
üí•      orderRepository.save(orderEntity);
üí•  }

}


[‚úèÔ∏è#~/...com.appsdeveloperblog.orders.service.handler.OrderCommandsHandler]
@Component
@KafkaListener(topics="${order.commands.topic.name}")
public class OrderCommandsHandler {

    private final OrderService orderService;

    public OrderCommandsHandler(OrderService orderService) {
      this.orderService = orderService;
    }

    @KafkaHandler
    public void handleCommand(@Payload ApproveOrderCommand approveOrderCommand) {
        orderService.approveOrder();
    }

üí•  @KafkaHandler
üí•  public void handleCommand(@Payload RejectOrderCommand command) {
üí•      orderService.rejectOrder(command.getOrderId());
üí•  }
}





~





üöÄ Saga Compensating Transactions - Trying how it works
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================================================================================

[terminal]
$ cd {WORKSPACE}
$ ls
README.md    docker-compose.yml    pom.xml
$ docker compose up
~
üßêüïµÔ∏è‚Äç‚ôÇÔ∏èüîé For this command to work your Docker Desktop application should be running on your computer


Since, we've made changes in our Project, we need to build our modules
[terminal]
$ cd {WORKSPACE}/core
$ mvn clean install

...

Now, let's run our orders & products service applications
[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù orders-service
  üêû OrdersServiceApplication
   - üõë OderSaga.handleEvent(@Payload PaymentFailedEvent event)
   - üõë OrderSaga.handleEvent(@Payload ProductReservationCancelledEvent event)
   - üõë OrderServiceImpl.rejectOrder
   ‚úèÔ∏è>>> Let's add some break points to confirm our Compensating Transactions were triggered...
üìù products-service
  ‚ñ∂Ô∏è ProductsServiceApplication  
üìù payments-service
  ‚ñ∂Ô∏è PaymentsServiceApplication
üìù credit-card-processor-service
  ‚ñ∂Ô∏è CreditCardProcessorApplication    
~
üßêüïµÔ∏è‚Äç‚ôÇÔ∏èüîé ¬¥payment-service¬¥ communicates with ¬¥credit-card-processor-service¬¥
 -> So, we'll start it aswell  


[POSTMAN]
[POST] http://localhost:8081/products
Params | Authorization | Headers | ‚úÖBody | Scripts | Test | settings
none | form-data | x-www-form-urlencoded | ‚úÖraw | binary | GraphQL | üí•JSON 
{
  "name":"iPhone 11",
  "price":1500,
  "quantity":5
}
  => SEND
~
Status: 201 Created  Time: 905 ms  Size: 259 B
{
  "id": {UUID}üí•
  "name":"iPhone 11",
  "price":1500,
  "quantity":1
}
‚úÖ Product has been created successfully


‚úèÔ∏è Let's now create a new order >>>
[POSTMAN]
[POST] http://localhost:8080/orders
Params | Authorization | Headers | ‚úÖBody | Scripts | Test | settings
none | form-data | x-www-form-urlencoded | ‚úÖraw | binary | GraphQL | üí•JSON 
{
  "productId":{UUID}üí•,
  "productQuantity":1,
  "customerId":"{anyValidUUID}"
}
~
Status: 202 Accepted  Time: 1417 ms  Size: 362 B
{
  "orderId":{orderID},
  "customerId": {customerID},
  "productId": {productID},
  "productsQuantity": 1,
  "status": "CREATED"
}


‚úèÔ∏è Let's now retrieve a list of status update for an specific order >>>
[POSTMAN]
[GET] http://localhost:8080/orders/{UUID}
Params | Authorization | Headers | ‚úÖBody | Scripts | Test | settings
none | form-data | x-www-form-urlencoded | ‚úÖraw | binary | GraphQL | üí•JSON 
~
[
  {
    "id": {UUID1},
    "orderId": {UUIDO1},
    "status": "CREATED",
    "createdAt": "2025-07-30T16:07:43.566+00:00"
  },
  {
    "id": {UUID2},
    "orderId": {UUIDo1},
    "status": "APPROVED",
    "createdAt": "2025-07-30T16:07:44.274+00:00"
  }
]


~


‚úèÔ∏è>>> Let's stop ¬¥credit-card-processor-service¬¥ application to make our PaymentFailedEvent get triggered
[IntelliJ]
<saga-pattern-spring-boot-demo>
üìù credit-card-processor-service
  ‚õî CreditCardProcessorApplication    


‚úèÔ∏è Let's now create a new order >>>
[POSTMAN]
[POST] http://localhost:8080/orders
Params | Authorization | Headers | ‚úÖBody | Scripts | Test | settings
none | form-data | x-www-form-urlencoded | ‚úÖraw | binary | GraphQL | üí•JSON 
{
  "productId":{UUID}üí•,
  "productQuantity":1,
  "customerId":"{anyValidUUID}"
}
~
Status: 202 Accepted  Time: 1417 ms  Size: 362 B
{
  "orderId":{orderID},
  "customerId": {customerID},
  "productId": {productID},
  "productsQuantity": 1,
  "status": "CREATED"
}

=> Now our orders-service should be triggered
üßêüïµÔ∏è‚Äç‚ôÇÔ∏èüîé Even though our request was "Accepted"
 -> We can check the Order status through Order History endpoing


‚úèÔ∏è Let's now retrieve a list of status update for an specific order >>>
[POSTMAN]
[GET] http://localhost:8080/orders/{UUID}
Params | Authorization | Headers | ‚úÖBody | Scripts | Test | settings
none | form-data | x-www-form-urlencoded | ‚úÖraw | binary | GraphQL | üí•JSON 
~
[
  {
    "id": {UUID1},
    "orderId": {UUIDO1},
    "status": "CREATED",
    "createdAt": "2025-07-30T16:07:43.566+00:00"
  },
  {
    "id": {UUID2},
    "orderId": {UUIDo1},
    "status": "REJECTED", üí•
    "createdAt": "2025-07-30T16:07:44.274+00:00"
  }
]